## JAVA

-------------------------------------------------------------------------------------------------

### JVM 이란?

JVM은 자바 가상 머신으로 원래 WORA를 구현하기 위해 물리적 머신과 별개의 가상 머신을 기반으로 동작하도록 설계 되었다. 자바 바이트 코드를 실행하고자 하는 모든 하드웨어에 JVM을 동작
시킴으로 자바 실행 코드를 변경하지 않고도 모든 종류의 하드웨어에서 동작되게 한 것이다.

JVM의 특징은 다음과 같다.

1. 스택 기반의 가상 머신 - 스택 기반으로 동작
2. 심볼릭 레퍼런스 - 명시적인 메모리 주소 기반의 레퍼런스가 아닌 심볼릭 레퍼런스를 통해 참조한다.
3. 가비지 컬렉션 - 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴된다.
4. 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장 
5. 네트워크 바이크 오더

### 자바 바이트 코드

JVM에선 자바와 기계어 사이의 중간 언어인 자바 바이트코드를 사용한다. 이 자바 바이트코드가 자바 코드를 배포하는 가장 작은 단위이다. 

### JVM 구조

![JVM 구조](https://d2.naver.com/content/images/2015/06/helloworld-1230-1.png)

클래스 로더가 컴파일된 자바 바이트코드를 런타임 데이터 영역에 로드하고, 실행 엔진이 자바 바이트코드를 실행한다.

### 클래스 로더

자바는 동적 로드, 즉 컴파일 타임이 아니라 런타임 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는 특징이 있다. 이 동적 로드를 담당하는 부분이 JVM의 클래스 로더이다.

특징을 살펴보면

1. 계층 구조 : 클래스 로더 끼리 부모 - 자식 관계를 이루어 계층 구조로 생성된다. 최상위 클래스로더는 부트스트랩 클래스로더이다.

2. 위임 모델 : 계층 구조를 바탕으로 클래스 로더끼리 로드를 위임하는 구조로 동작한다. 클래스를 로드할 때 먼저 상위 클래스로더를 확인하여 상위 클래스 로더에 있다면
              해당 클래스를 사용하고, 없다면 로드를 요청받는 클래스로더가 클래스를 로드한다.
             
3. 언로드 불가 : 클래스로더는 클래스를 로드할 수는 있지만 언로드할 수는 없다. 언로드 대신, 현재 클래스 로더를 삭제하고 아예 새로운 클래스 로더를 생성한느 방법을 사용할 수 있다.

각 클래스 로더는 로드된 클래스들을 보관하는 네임스페이스를 갖는다. 클래스를 로드할 때 이미 로드된 클래스인지 확인하기 위해서 네임스페이스 보관된 FQCN을 기준으로 클래스를 찾는다.
비록 같더라도 네임스페이스가 다르면 다른 클래스로 간주된다.

![클래스 로더 모델](https://d2.naver.com/content/images/2015/06/helloworld-1230-2.png)

- 부트스트랩 클래스 로더 : JVM을 기동할 때 생성되며, Object 클래스들을 비롯하여 자바 API들을 로드한다. 다른 클래스 로더와 달리 자바가 아니라 네이티브 코드로 구현되어 있다.

- 익스텐션 클래스 로더 : 기본 자바 API를 제외한 확장 클래스들을 로드한다. 다양한 보안 확장 기능 등을 여기에서 로드 하게 된다.

- 시스템 클래스 로더 : 애플리케이션의 클래스들을 로드한다고 할 수 있다. 사용자가 지정한 $CLASSPATH내의 클래스들을 로드한다.

클래스 로더가 아직 로드되지 않은 클래스를 찾으면, 다음 과정을 거쳐 클래스를 로드하고 링크하고 초기화한다.

1. 로드 : 클래스를 파일에서 가져와서 JVM의 메모리에 로드한다.

2. 검증 : 읽어 들인 클래스가 자바 언어 명세 및 JVM 명세에 명시된 대로 잘 구성되어 있는지 검사한다.

3. 준비 : 클래스가 필요로하는 메모리를 할당하고, 클래스에서 정의된 필드, 메서드 인터페이스들을 나타내는 데이터 구조를 준비한다.

4. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.

5. 초기화 : 클래스 변수들을 적절한 값으로 초기화 한다.

### 런타임 데이터 영역

런타임 데이터 영역에는 PC레지스터, JVM 스택, 네이티브 메서드 스택이 스레드마다 하나씩 생성되고 힙, 메서드 영역, 런타임 상수 풀은 모든 스레드가 공유해서 사용한다.

- PC 레지스터 : PC 레지스터는 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. PC 레지스터는 현재 수행 중인 JVM 명령의 주소를 갖는다.

- JVM 스택 : JVM 스택은 각 스레드마다 하나 씩 존재하며 스레드가 생성될 때 생성된다. 스택 프레임 이라는 구조체를 저장하는 스택으로, JVM은 오직 JVM 스택에 스택 프레임을 추가하고 제거만 한다.

- 스택 프레임 : JVM 내에서 메서드가 수행될 때 마다 생셩되며 종료되면 제거된다. 지역 변수 배열, 피연산자 스택, 상수 풀에 대한 레퍼런스를 갖는다.

- 지역 변수 배열 : 0부터 시작하는 인덱스를 가진 배열, 0은 메서드가 속한 클래스 인스턴스의 this 래퍼런스이고, 1부터 전달된 파라미터들이 저장 이후 메서드의 지역 변수들이 저장된다.

- 피연산자 스택 : 메서드의 실제 작업 공간 각 메서드는 피연산자 스택과 지역 변수 배열 사이에서 데이터를 교환하고, 다른 메서드 호출 결과를 추가하거나 꺼냄

- 네이티브 메서드 스택 : 자바외의 언어로 작성된 네이티브 코드를 위한 스택

- 메서드 영역 : 메서드 영역은 모든 스레드가 공유, JVM이 시작돌 때 생성된다. JVM이 읽어 들인 클래스와 인터페이스에 대한 런타임 상수 풀, 등등을 보관한다.

- 런타임 상수 풀 : 클래스 파일 포맷에서 constant_pool 테이블에 해당하는 영역, 각 클래스와 인터페이스 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블

- 힙 : 인스턴스 또는 객체를 저장하는 공간으로 가비지 컬렉션의 대상 JVM 성능 등의 이슈에서 가장 많이 언급됨

### 실행 엔진

자바 바이트코드는 기계가 바로 수행할 수 있는 언어 보다는 인간이 보기 편한 형태로 기술된 것이라 내부에서 기계가 실행할 수 있는 형태로 변경되야한다.

두 가지 방식이 있다.

- 인터프리터 : 바이트코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나씩 해석하고 실행하기 때문에 바이트코드 하나 하나의 해석은 빠른 대신 인터프리팅 결과의
              실행은 느리다는 단점을 갖고 있다.
              
- JIT 컴파일러 : 인터프리터의 단점을 보완하기 위해 도입된 것으로 인터프리터로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 
                해당 메서드를 더 이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식이다.
