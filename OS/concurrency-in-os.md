# OS 프로세스간 동기화 이슈

프로세스간에 동기화를 해주지 않고 여러 프로세스에서 하나의 공유 자원을 놓고 수정을 시도하면 동시성 이슈가 발생할 수 밖에 없습니다. 대표적인 사례로 여러 프로세스가 하나의 파일을
수정할 경우인데 이 경우 어떻게 문제가 생기고 어떻게 해결하는지를 알아보자.

## 프로세스가 파일을 수정하는 과정 

- 파일을 연다 이 때 프로세스는 시스템 호출 (`open`, `fopen`)을 통해 커널에 파일을 열어달라고 요청
    - 경로 탐색: 주어진 파일 경로를 탐색하여 해당 파일이 존재하는지 확인
    - 파일 존재 여부 확인하여 존재한다면 파일의 메타데이터 정보를 가져온다.
    - 커널은 프로세스의 파일 디스크립터 테이블에 새로운 항목을 추가
    - 커널은 프로세스에게 파일 디스크립터를 반환, 이 파일 디스크립터는 프로세스가 이후에 파일을 참조하는데 사용

- 파일을 열고 잠금이 설정 되면, 프로세스는 파일을 읽거나 쓸 수 있다.
    - 프로세스는 데이터를 메모리의 버퍼에 준비한다.
    - `write` 시스템 호출을 통해 커널에 데이터를 파일에 쓰도록 요청
    - 커널은 파일의 현재 오프셋을 확인하고, 데이터가 쓰일 위치를 설정
    - 커널은 프로세스의 버퍼에서 데이터를 읽어 파일 시스템의 페이지 캐시로 복사
    - 디스크 쓰기 요청 페이지 캐시에 저장된 데이터는 이후 디스크로 기록 이 과정은 비동기로 이루어질 수도 있음

- 파일 작업이 끝나면 프로세스는 파일을 닫는다. `close` system call을 통해 이루어짐
    - 파일 디스크립터를 반환 한다.
    - 커널은 해당 파일 테이블 항목의 참조 카운트를 감소시킨다. 
    - 참조 카운트가 0이 되면, 커널은 해당 파일 테이블 항목을 해제하고, 관련 자원을 반환

## 파일 잠금을 통해서 동기화 이슈를 해결하자 

- 동시성 문제를 피하기 위해 파일 잠금이 필요할 수 있다. flock, fcntl 시스템을 호출하여 잠금을 설정가능하다.
    - 파일 잠금 요청: 프로세스는 커널에 파일 잠금을 요청
    - 잠금 설정: 커널은 파일의 현재 잠금 상태를 확인하고, 잠금을 설정한다. 다른 프로세스가 동일한 파일에 접근하려고 하면 이 잠금 상태를 확인하여 접근을 제어

- Mutex나 semaphore를 활용하여 잠금을 구현할 수 있다. 이를 이용해서 여러 프로세스가 자원을 동시에 변경하는것을 막을 수 있다.

## 용어 정리

파일 시스템에서의 오프셋: 일반 파일에서 오프셋은 파일의 시작점에서부터 얼마나 떨어진 지점에 데이터를 읽거나 쓸 것인지를 나타내는 정수 값.
